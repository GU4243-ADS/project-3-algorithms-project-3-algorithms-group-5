# Methods used to deal with log/exp overflow
print(paste(iter, "E-step done!"))
# M-step
## Update mu
mu<- apply(aic_assignment, 2, mean)
## Update gamma_array
# nominator first
for(c in 1:C){
for(k in 1:6){
for(j in colnames(data)){
indicator[,j,k]<-ifelse(data[,j]==k,1,0)
nomi[j,k,c]<-sum(aic_assignment[,c]* indicator[,j,k],na.rm = T)
deno_indicator[,j]<-ifelse(is.na(data[,j]),0,1)
# denominator
deno[j,c]<-sum(aic_assignment[,c]*deno_indicator[,j],na.rm = T)
}
}
}
# denominator
#deno[j,c]<-
for (c in 1:C) {
for (j in colnames(data)) {
if(deno[j,c]==0){
deno[j,c]<-0.0001
}
gamma_array[j,,c]<-nomi[j,,c]/deno[j,c]
}
}
print(paste(iter, "M-step done!"))
convergence_t<-norm(aic_assignment-aic_assignment_old, 'O')
print(paste("The norm is", convergence_t))
print(paste("Iteration", iter, "done!"))
iter<-iter+1
}
return(list(mu=mu, gamma_array=gamma_array, aic_assignment=aic_assignment,aic_assignment_old=aic_assignment_old))
}
system.time(results<-EM_for_CF(movie_UI,3))
results$aic_assignment
apply(results$aic_assignment, 1, sum)
save(results,file = "EM_3.RData")
getwd
getwd()
system.time(results<-EM_for_CF(movie_UI,5))
save(results,file = "EM_5.RData")
EM_for_CF<- function(data, C, t=0.001){
# data<-movie_UI
# C<-3
# Initialize parameters
#mu<-rep((1/C),C)
#gamma_array<- array(1/6, dim=c(ncol(data), 6, C),
#                   dimnames = list(colnames(data),
#                                  c("1", "2", "3","4","5","6"),
#                                 c(1:C)))
#uniformed initial value caused local maximum?? see in Pizza
mu<- runif(C, 1, 10)
mu<- mu/sum(mu)
gamma_array<- array(runif(ncol(data)*6*C, 1, 10), dim=c(ncol(data), 6, C),
dimnames = list(colnames(data),
c("1", "2", "3","4","5","6"),
c(1:C)))
for(c in 1:C){gamma_array[, , c]<- gamma_array[, , c]/rowSums(gamma_array[, , c])}
nomi<- array(0, dim=c(ncol(data), 6, C),
dimnames = list(colnames(data),
c("1", "2", "3","4","5","6"),
c(1:C)))
aic_assignment<- matrix(0, ncol=C, nrow=nrow(data))
aic_assignment_old<- matrix(0, ncol=C, nrow=nrow(data))
sum_log_gamma<-matrix(0, ncol=C, nrow=nrow(data))
nominator<-matrix(0, ncol=C, nrow=nrow(data))
indicator<-array(NA, dim=c(nrow(data), ncol(data), 6),
dimnames = list(rownames(data),
colnames(data),
c("1", "2", "3","4","5","6")))
deno_indicator<-matrix(NA, nrow=nrow(data),ncol=ncol(data),
dimnames = list(rownames(data),
colnames(data)))
deno<- matrix(0, nrow=ncol(data), ncol=C,
dimnames = list(colnames(data),
c(1:C)))
##some of them may in loop
denominator<-rep(1,C)
#print("Initialization is done!")
# set convergence criterion
iter <-1
convergence_t <-1
while (iter < 12 & convergence_t > t ) {
aic_assignment_old<- aic_assignment
# E-step
## Update aic_assignment
log_gamma<-log(gamma_array)
log_mu<-log(mu)
for(c in 1:C){
for (i in 1:nrow(data)) {
for (k in 1:6) {
###nominator first
index<-which(data[i,]==k)
sum_log_gamma[i,c]<-sum_log_gamma[i,c]+sum(log_gamma[index,k,c])
nominator[i,c]<-log_mu[c]+sum_log_gamma[i,c]
}
###denominator
# denominator333<- apply(nominator,2,sum)
# need to be tested...Maybe also need log again and overflow again??
# a_max_xn<- max(sum_log_gamma+log(mu)) seems like the 2 links are replacable?
denominator[i]<-logSumExp(nominator[i,])
#nominator[,c]? log_mu[c]+sum_log_gamma[i,c]?
######## Important ####### Be aware of the dimension of denominator!!! It is 5055*1,
# C is in sum!!!! It is the col sum of numerator
# The above [,c] or [i,c] is different!!!!
}
}
for(c in 1:C){
aic_assignment[,c]<-exp(nominator[,c]-denominator)
}
# https://hips.seas.harvard.edu/blog/2013/01/09/computing-log-sum-exp/ & LogSumExp in "matrixStats" package
# Methods used to deal with log/exp overflow
print(paste(iter, "E-step done!"))
# M-step
## Update mu
mu<- apply(aic_assignment, 2, mean)
## Update gamma_array
# nominator first
for(c in 1:C){
for(k in 1:6){
for(j in colnames(data)){
indicator[,j,k]<-ifelse(data[,j]==k,1,0)
nomi[j,k,c]<-sum(aic_assignment[,c]* indicator[,j,k],na.rm = T)
deno_indicator[,j]<-ifelse(is.na(data[,j]),0,1)
# denominator
deno[j,c]<-sum(aic_assignment[,c]*deno_indicator[,j],na.rm = T)
}
}
}
# in case denominator==0
for (c in 1:C) {
for (j in colnames(data)) {
if(deno[j,c]==0){
deno[j,c]<-0.0001
}
gamma_array[j,,c]<-nomi[j,,c]/deno[j,c]
}
}
print(paste(iter, "M-step done!"))
convergence_t<-norm(aic_assignment-aic_assignment_old, 'O')
print(paste("The norm is", convergence_t))
print(paste("Iteration", iter, "done!"))
iter<-iter+1
}
return(list(mu=mu, gamma_array=gamma_array, aic_assignment=aic_assignment,aic_assignment_old=aic_assignment_old))
}
system.time(results<-EM_for_CF(movie_UI,7))
sum(results$gamma_array[1,])
sum(results$gamma_array[1,,1])
sum(results$gamma_array[2,,1])
sum(results$gamma_array[2,,3])
save(results,file = "EM_7.RData")
system.time(results<-EM_for_CF(movie_UI,9))
results$gamma_array[1]
dim(results$gamma_array)[1]
dim(results$gamma_array)[2]
dim(results$gamma_array)[3]
apply(results$aic_assignment, 1, max)[1:10]
results$aic_assignment[1:10,]
apply(results$aic_assignment, 1, max)[1:10,]
apply(results$aic_assignment, 1, max)
which(apply(aic, 1, max))
which(apply(results$aic_assignment, 1, max))
system.time(results<-EM_for_CF(movie_UI,11))
save(results,file = "EM_11.RData")
apply(results$aic_assignment, 1, which.max)
c(1:dim(gamma)[2])
c(1:dim(results$gamma_array)[2])
movie_EM_pred_11 <- movie_EM_pred(results$gamma_array,results$aic_assignment)
##Pred value
movie_EM_pred<-function(gamma,aic){
pred<-matrix(NA,nrow=dim(aic)[1],ncol=dim(gamma)[1])
cluster_of_user<-apply(aic, 1, which.max)
rate<-c(1:dim(gamma)[2])
for (i in 1:dim(aic)[1]) {
for (j in 1:dim(gamma)[1]) {
pred[i,j]<-sum(gamma[j,,cluster[i]]*rate)
}
}
return(movie_EM_pred=pred)
}
movie_EM_pred_11 <- movie_EM_pred(results$gamma_array,results$aic_assignment)
##Pred value
movie_EM_pred<-function(gamma,aic){
pred<-matrix(NA,nrow=dim(aic)[1],ncol=dim(gamma)[1])
cluster_of_user<-apply(aic, 1, which.max)
rate<-c(1:dim(gamma)[2])
for (i in 1:dim(aic)[1]) {
for (j in 1:dim(gamma)[1]) {
pred[i,j]<-sum(gamma[j,,cluster_of_user[i]]*rate)
}
}
return(movie_EM_pred=pred)
}
movie_EM_pred_11 <- movie_EM_pred(results$gamma_array,results$aic_assignment)
movie_EM_pred_11[1:10,1:10]
# movie_EM_pred_11[1:10,1:10]
save(movie_EM_pred_11,file = "movie_EM_pred_11.RData")
EM_for_CF<- function(data, C, t=0.001){
# data<-movie_UI
# C<-3
# Initialize parameters
#mu<-rep((1/C),C)
#gamma_array<- array(1/6, dim=c(ncol(data), 6, C),
#                   dimnames = list(colnames(data),
#                                  c("1", "2", "3","4","5","6"),
#                                 c(1:C)))
#uniformed initial value caused local maximum?? see in Pizza
mu<- runif(C, 1, 10)
mu<- mu/sum(mu)
gamma_array<- array(runif(ncol(data)*6*C, 1, 10), dim=c(ncol(data), 6, C),
dimnames = list(colnames(data),
c("1", "2", "3","4","5","6"),
c(1:C)))
for(c in 1:C){gamma_array[, , c]<- gamma_array[, , c]/rowSums(gamma_array[, , c])}
nomi<- array(0, dim=c(ncol(data), 6, C),
dimnames = list(colnames(data),
c("1", "2", "3","4","5","6"),
c(1:C)))
aic_assignment<- matrix(0, ncol=C, nrow=nrow(data))
aic_assignment_old<- matrix(0, ncol=C, nrow=nrow(data))
sum_log_gamma<-matrix(0, ncol=C, nrow=nrow(data))
nominator<-matrix(0, ncol=C, nrow=nrow(data))
indicator<-array(NA, dim=c(nrow(data), ncol(data), 6),
dimnames = list(rownames(data),
colnames(data),
c("1", "2", "3","4","5","6")))
deno_indicator<-matrix(NA, nrow=nrow(data),ncol=ncol(data),
dimnames = list(rownames(data),
colnames(data)))
deno<- matrix(0, nrow=ncol(data), ncol=C,
dimnames = list(colnames(data),
c(1:C)))
##some of them may in loop
denominator<-rep(1,C)
#print("Initialization is done!")
# set convergence criterion
iter <-1
convergence_t <-1
##iter < 12 &
while ( convergence_t > t ) {
aic_assignment_old<- aic_assignment
# E-step
## Update aic_assignment
log_gamma<-log(gamma_array)
log_mu<-log(mu)
for(c in 1:C){
for (i in 1:nrow(data)) {
for (k in 1:6) {
###nominator first
index<-which(data[i,]==k)
sum_log_gamma[i,c]<-sum_log_gamma[i,c]+sum(log_gamma[index,k,c])
nominator[i,c]<-log_mu[c]+sum_log_gamma[i,c]
}
###denominator
# denominator333<- apply(nominator,2,sum)
# need to be tested...Maybe also need log again and overflow again??
# a_max_xn<- max(sum_log_gamma+log(mu)) seems like the 2 links are replacable?
denominator[i]<-logSumExp(nominator[i,])
#nominator[,c]? log_mu[c]+sum_log_gamma[i,c]?
######## Important ####### Be aware of the dimension of denominator!!! It is 5055*1,
# C is in sum!!!! It is the col sum of numerator
# The above [,c] or [i,c] is different!!!!
}
}
for(c in 1:C){
aic_assignment[,c]<-exp(nominator[,c]-denominator)
}
# https://hips.seas.harvard.edu/blog/2013/01/09/computing-log-sum-exp/ & LogSumExp in "matrixStats" package
# Methods used to deal with log/exp overflow
print(paste(iter, "E-step done!"))
# M-step
## Update mu
mu<- apply(aic_assignment, 2, mean)
## Update gamma_array
# nominator first
for(c in 1:C){
for(k in 1:6){
for(j in colnames(data)){
indicator[,j,k]<-ifelse(data[,j]==k,1,0)
nomi[j,k,c]<-sum(aic_assignment[,c]* indicator[,j,k],na.rm = T)
deno_indicator[,j]<-ifelse(is.na(data[,j]),0,1)
# denominator
deno[j,c]<-sum(aic_assignment[,c]*deno_indicator[,j],na.rm = T)
}
}
}
# in case denominator==0
for (c in 1:C) {
for (j in colnames(data)) {
if(deno[j,c]==0){
deno[j,c]<-0.0001
}
gamma_array[j,,c]<-nomi[j,,c]/deno[j,c]
}
}
print(paste(iter, "M-step done!"))
convergence_t<-norm(aic_assignment-aic_assignment_old, 'O')
print(paste("The norm is", convergence_t))
print(paste("Iteration", iter, "done!"))
iter<-iter+1
}
return(list(mu=mu, gamma_array=gamma_array, aic_assignment=aic_assignment,aic_assignment_old=aic_assignment_old))
}
system.time(results<-EM_for_CF(movie_UI,9))
unique(movie_UI)
MS_for_CF<- function(data, C, t=0.001){
# Initialize parameters
mu<- runif(C, 1, 10)
mu<- mu/sum(mu)
gamma_array<- array(runif(ncol(data)*2*C, 1, 10), dim=c(ncol(data), 2, C),
dimnames = list(colnames(data),
c("1", "2"),
c(1:C)))
for(c in 1:C){gamma_array[, , c]<- gamma_array[, , c]/rowSums(gamma_array[, , c])}
nomi<- array(0, dim=c(ncol(data), 2, C),
dimnames = list(colnames(data),
c("1", "2"),
c(1:C)))
aic_assignment<- matrix(0, ncol=C, nrow=nrow(data))
aic_assignment_old<- matrix(0, ncol=C, nrow=nrow(data))
sum_log_gamma<-matrix(0, ncol=C, nrow=nrow(data))
nominator<-matrix(0, ncol=C, nrow=nrow(data))
indicator<-array(NA, dim=c(nrow(data), ncol(data), 2),
dimnames = list(rownames(data),
colnames(data),
c("1", "2")))
deno_indicator<-matrix(NA, nrow=nrow(data),ncol=ncol(data),
dimnames = list(rownames(data),
colnames(data)))
deno<- matrix(0, nrow=ncol(data), ncol=C,
dimnames = list(colnames(data),
c(1:C)))
##some of them may in loop
denominator<-rep(1,C)
#print("Initialization is done!")
# set convergence criterion
iter <-1
convergence_t <-1
##
while ( iter < 12 & convergence_t > t ) {
aic_assignment_old<- aic_assignment
# E-step
## Update aic_assignment
log_gamma<-log(gamma_array)
log_mu<-log(mu)
for(c in 1:C){
for (i in 1:nrow(data)) {
for (k in 1:2) {
###nominator first
index<-which(data[i,]==k)
sum_log_gamma[i,c]<-sum_log_gamma[i,c]+sum(log_gamma[index,k,c])
nominator[i,c]<-log_mu[c]+sum_log_gamma[i,c]
}
denominator[i]<-logSumExp(nominator[i,])
}
}
for(c in 1:C){
aic_assignment[,c]<-exp(nominator[,c]-denominator)
}
# https://hips.seas.harvard.edu/blog/2013/01/09/computing-log-sum-exp/ & LogSumExp in "matrixStats" package
# Methods used to deal with log/exp overflow
print(paste(iter, "E-step done!"))
# M-step
## Update mu
mu<- apply(aic_assignment, 2, mean)
## Update gamma_array
# nominator first
for(c in 1:C){
for(k in 1:2){
for(j in colnames(data)){
indicator[,j,k]<-ifelse(data[,j]==k,1,0)
nomi[j,k,c]<-sum(aic_assignment[,c]* indicator[,j,k],na.rm = T)
deno_indicator[,j]<-ifelse(is.na(data[,j]),0,1)
# denominator
deno[j,c]<-sum(aic_assignment[,c]*deno_indicator[,j],na.rm = T)
}
}
}
# in case denominator==0
for (c in 1:C) {
for (j in colnames(data)) {
if(deno[j,c]==0){
deno[j,c]<-0.0001
}
gamma_array[j,,c]<-nomi[j,,c]/deno[j,c]
}
}
print(paste(iter, "M-step done!"))
convergence_t<-norm(aic_assignment-aic_assignment_old, 'O')
print(paste("The norm is", convergence_t))
print(paste("Iteration", iter, "done!"))
iter<-iter+1
}
return(list(mu=mu, gamma_array=gamma_array, aic_assignment=aic_assignment,aic_assignment_old=aic_assignment_old))
}
system.time(results<-MS_for_CF(MS_UI,9))
MS_for_CF<- function(data, C, t=0.001){
# Initialize parameters
mu<- runif(C, 1, 10)
mu<- mu/sum(mu)
gamma_array<- array(runif(ncol(data)*2*C, 1, 10), dim=c(ncol(data), 2, C),
dimnames = list(colnames(data),
c("1", "2"),
c(1:C)))
for(c in 1:C){gamma_array[, , c]<- gamma_array[, , c]/rowSums(gamma_array[, , c])}
nomi<- array(0, dim=c(ncol(data), 2, C),
dimnames = list(colnames(data),
c("1", "2"),
c(1:C)))
aic_assignment<- matrix(0, ncol=C, nrow=nrow(data))
aic_assignment_old<- matrix(0, ncol=C, nrow=nrow(data))
sum_log_gamma<-matrix(0, ncol=C, nrow=nrow(data))
nominator<-matrix(0, ncol=C, nrow=nrow(data))
indicator<-array(NA, dim=c(nrow(data), ncol(data), 2),
dimnames = list(rownames(data),
colnames(data),
c("1", "2")))
deno_indicator<-matrix(NA, nrow=nrow(data),ncol=ncol(data),
dimnames = list(rownames(data),
colnames(data)))
deno<- matrix(0, nrow=ncol(data), ncol=C,
dimnames = list(colnames(data),
c(1:C)))
##some of them may in loop
denominator<-rep(1,C)
#print("Initialization is done!")
# set convergence criterion
iter <-1
convergence_t <-1
##
while ( iter < 15 & convergence_t > t ) {
aic_assignment_old<- aic_assignment
# E-step
## Update aic_assignment
log_gamma<-log(gamma_array)
log_mu<-log(mu)
for(c in 1:C){
for (i in 1:nrow(data)) {
for (k in 1:2) {
###nominator first
index<-which(data[i,]==k)
sum_log_gamma[i,c]<-sum_log_gamma[i,c]+sum(log_gamma[index,k,c])
nominator[i,c]<-log_mu[c]+sum_log_gamma[i,c]
}
denominator[i]<-logSumExp(nominator[i,])
}
}
for(c in 1:C){
aic_assignment[,c]<-exp(nominator[,c]-denominator)
}
# https://hips.seas.harvard.edu/blog/2013/01/09/computing-log-sum-exp/ & LogSumExp in "matrixStats" package
# Methods used to deal with log/exp overflow
print(paste(iter, "E-step done!"))
# M-step
## Update mu
mu<- apply(aic_assignment, 2, mean)
## Update gamma_array
# nominator first
for(c in 1:C){
for(k in 1:2){
for(j in colnames(data)){
indicator[,j,k]<-ifelse(data[,j]==k,1,0)
nomi[j,k,c]<-sum(aic_assignment[,c]* indicator[,j,k],na.rm = T)
deno_indicator[,j]<-ifelse(is.na(data[,j]),0,1)
# denominator
deno[j,c]<-sum(aic_assignment[,c]*deno_indicator[,j],na.rm = T)
}
}
}
# in case denominator==0
for (c in 1:C) {
for (j in colnames(data)) {
if(deno[j,c]==0){
deno[j,c]<-0.0001
}
gamma_array[j,,c]<-nomi[j,,c]/deno[j,c]
}
}
print(paste(iter, "M-step done!"))
convergence_t<-norm(aic_assignment-aic_assignment_old, 'O')
print(paste("The norm is", convergence_t))
print(paste("Iteration", iter, "done!"))
iter<-iter+1
}
return(list(mu=mu, gamma_array=gamma_array, aic_assignment=aic_assignment,aic_assignment_old=aic_assignment_old))
}
system.time(results<-MS_for_CF(MS_UI,9))
save(results,file = "MS_for_CF_9.RData")
##Pred value
movie_EM_pred<-function(gamma,aic){
pred<-matrix(NA,nrow=dim(aic)[1],ncol=dim(gamma)[1])
cluster_of_user<-apply(aic, 1, which.max)
rate<-c(1:dim(gamma)[2])
for (i in 1:dim(aic)[1]) {
for (j in 1:dim(gamma)[1]) {
pred[i,j]<-sum(gamma[j,,cluster_of_user[i]]*rate)
}
}
return(movie_EM_pred=pred)
}
MS_EM_pred_9 <- movie_EM_pred(results$gamma_array,results$aic_assignment)
MS_EM_pred_9[1:10,1:10]
save(MS_EM_pred_9,file = "MS_EM_pred_9.RData")
load("/Users/mac/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/963f751c957b4af9f121de921ca2c57c/Message/MessageTemp/097e01e54e2f763fbb35d166a1ac10c4/File/MS_sim_spearman.RData")
pred_matrix(MS_UI_matrix, MS_sim_spearman)
pred_matrix(MS_UI, MS_sim_spearman)
load("/Users/mac/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/963f751c957b4af9f121de921ca2c57c/Message/MessageTemp/097e01e54e2f763fbb35d166a1ac10c4/File/MS_sim_spearman.RData")
pred_matrix(MS_UI, MS_sim)
